<!DOCTYPE html>
<html lang="pt-br">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>DEXTROY</title>

    <style>
        /* CSS Integrado */
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { background-color: #0d0221; overflow: hidden; font-family: 'Consolas', 'Courier New', monospace; color: white; }

        .screen { position: absolute; top: 0; left: 0; width: 100%; height: 100%; display: flex; flex-direction: column; justify-content: center; align-items: center; text-align: center; background: #0d0221; padding: 20px; transition: opacity 0.5s; z-index: 100; }
        .hidden { display: none !important; }
        
        #menuScreen h1 {
            font-size: clamp(4em, 15vw, 8em);
            color: #E1F2FE;
            letter-spacing: 5px;
            margin-bottom: 40px;
            animation: cosmic-pulse 3s infinite alternate;
        }

        @keyframes cosmic-pulse {
            from { text-shadow: 0 0 10px #30BCED, 0 0 20px #30BCED, 0 0 30px #5B8FB9, 0 0 40px #5B8FB9; }
            to { text-shadow: 0 0 5px #30BCED, 0 0 10px #30BCED, 0 0 15px #5B8FB9, 0 0 20px #5B8FB9; }
        }

        .button { background: transparent; border: 2px solid #30BCED; color: #30BCED; text-shadow: 0 0 5px #30BCED; padding: 15px 30px; font-size: clamp(1em, 5vw, 1.2em); border-radius: 0; cursor: pointer; width: 80%; max-width: 300px; margin-top: 15px; transition: background-color 0.3s, color 0.3s, box-shadow 0.3s; }
        .button:hover { background-color: #30BCED; color: #03001C; box-shadow: 0 0 20px #30BCED; }
        .button.challenge-btn { border-color: #ff4500; color: #ff4500; }
        .button.challenge-btn:hover { background-color: #ff4500; color: #03001C; box-shadow: 0 0 20px #ff4500; }

        #menuScreen input { width: 80%; max-width: 300px; padding: 15px; font-size: 1.1em; border-radius: 0; border: 2px solid #30BCED; background-color: rgba(0,0,0,0.3); color: white; text-align: center; margin-bottom: 20px; }
        #leaderboardList { list-style: none; width: 90%; max-width: 400px; max-height: 60vh; overflow-y: auto; background-color: rgba(0,0,0,0.3); border: 1px solid #5B8FB9; padding: 10px; }
        #leaderboardList li { display: flex; justify-content: space-between; padding: 5px; border-bottom: 1px solid #5B8FB9; }
        
        #gameOverModal #modalContent p { margin: 10px 0; font-size: 1.2em; }

        /* ----- Elementos do Jogo (UI) ----- */
        #gameContainer.crosshair-cursor { cursor: crosshair; }
        #gameCanvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #000;
        }
        
        #top-left-ui { position: absolute; top: 10px; left: 10px; font-size: 18px; user-select: none; background-color: rgba(0,0,0,0.3); padding: 10px; border-radius: 8px; display: flex; flex-direction: column; gap: 5px; border: 1px solid rgba(255, 165, 0, 0.5); }
        #stats-display { display: flex; flex-wrap: wrap; gap: 10px 20px; }

        #health-bar-container { width: 220px; height: 24px; background-color: rgba(255, 165, 0, 0.2); border: 1px solid #FFA500; border-radius: 0; position: relative; }
        #health-bar { width: 100%; height: 100%; background: linear-gradient(90deg, #4CAF50, #98FB98); transition: width 0.2s; }
        #health-text { position: absolute; top: 0; left: 0; width: 100%; height: 100%; display: flex; justify-content: center; align-items: center; font-size: 14px; font-weight: bold; text-shadow: 1px 1px 2px black; }

        #pc-bottom-ui { position: absolute; bottom: 10px; left: 50%; transform: translateX(-50%); display: flex; align-items: flex-end; gap: 10px; z-index: 10; padding: 5px; background-color: rgba(13, 2, 28, 0.7); border-radius: 10px; border: 1px solid rgba(48, 188, 237, 0.5); }
        #pc-abilities-ui, #pc-upgrades-ui { display: flex; gap: 5px; }
        
        .ability { width: 50px; height: 50px; border: 2px solid #07dfd8; border-radius: 8px; position: relative; display: flex; align-items: center; justify-content: center; font-size: 1.3em; font-weight: bold; user-select: none; }
        .ability .cooldown-overlay { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(249, 35, 226, 0.7); display: flex; align-items: center; justify-content: center; font-size: 0.7em; transition: height 0.1s linear; overflow: hidden; border-radius: 6px; }
        .ability .ability-key { position: absolute; top: 1px; left: 3px; font-size: 0.5em; }
        .ability .count-display { position: absolute; bottom: 1px; right: 3px; font-size: 0.6em; background: rgba(0,0,0,0.7); padding: 1px 3px; border-radius: 4px; }
        
        .upgrade-card { display: flex; flex-direction: column; align-items: center; padding: 10px; background: rgba(30, 30, 30, 0.8); border: 1px solid #ffac33; width: 90px; border-radius: 8px; text-align: center; }
        .upgrade-card.disabled { border-color: #a83232; color: #777;}
        .upgrade-card.disabled .upgrade-header, .upgrade-card.disabled .upgrade-buy button { color: #777; }
        .upgrade-header { display: flex; align-items: center; justify-content: center; gap: 5px; margin-bottom: 2px; }
        .upgrade-icon { font-size: 1em; }
        .upgrade-title { font-size: 0.7em; }
        .upgrade-level { font-size: 0.6em; margin-bottom: 4px; }
        .upgrade-buy { display: flex; align-items: center; gap: 5px; margin-top: 5px; }
        .upgrade-buy button { background: #ffac33; border: none; color: black; font-size: 1.2em; width: 25px; height: 25px; cursor: pointer; border-radius: 5px;}
        .upgrade-buy button:disabled { background: #555; cursor: not-allowed; }
        .upgrade-cost { font-size: 0.7em; }

        /* Joysticks e Botões Mobile */
        #joystick-container { position: absolute; bottom: 0; left: 0; width: 100%; height: 180px; display: flex; justify-content: space-between; align-items: center; padding: 0 20px;}
        .joystick-zone { width: 120px; height: 120px; display: flex; justify-content: center; align-items: center; }
        .joystick-base { width: 100px; height: 100px; background-color: rgba(249, 35, 226, 0.2); border: 2px solid #f923e2; border-radius: 50%; }
        .joystick-stick { width: 50px; height: 50px; background-color: rgba(7, 223, 216, 0.5); border-radius: 50%; position: absolute; }
        
        #mobile-abilities-ui { position: absolute; right: 20px; bottom: 180px; display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 15px; }
        #mobile-abilities-ui .ability { width: 55px; height: 55px; font-size: 1.2em; border-color: #FFD700; }
        #mobile-upgrade-button { border-color: #ffac33 !important; }

        #mobileUpgradeScreen .upgrade-container { display: grid; grid-template-columns: 1fr 1fr; gap: 15px; width: 95%; max-width: 500px; max-height: 70vh; overflow-y: auto; padding: 15px;}
        #mobileUpgradeScreen .upgrade-card { width: auto; flex-direction: column; justify-content: center; height: 140px; }
        #mobileUpgradeScreen .upgrade-info { text-align: center; }
        #mobileUpgradeScreen .upgrade-title { font-size: 0.9em; }
        #mobileUpgradeScreen .upgrade-level, #mobileUpgradeScreen .upgrade-cost { font-size: 0.8em; }
        #mobileUpgradeScreen .upgrade-buy button { width: 40px; height: 40px; font-size: 1.5em; }

        #tutorial-overlay {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0,0,0,0.7);
            border: 2px solid #07dfd8;
            padding: 20px 40px;
            font-size: 1.5em;
            text-align: center;
            z-index: 20;
        }

    </style>
</head>
<body>
    <div id="menuScreen" class="screen">
        <h1 id="main-title">DEXTROY</h1>
        <div class="menu-content">
            <input type="text" id="playerNameInput" placeholder="Digite seu nome">
            <div id="platform-selection"> 
                <button id="startPCButton" class="button">Jogar no PC</button> 
                <button id="startMobileButton" class="button">Jogar no Celular</button>
                <button id="challengePCButton" class="button challenge-btn">Desafio (PC)</button> 
                <button id="challengeMobileButton" class="button challenge-btn">Desafio (Mobile)</button> 
                <button id="tutorialButton" class="button">Como Jogar</button>
                <button id="continueButton" class="button hidden">Continuar Jogo</button>
                <button id="leaderboardButton" class="button">Placar</button>
            </div>
        </div>
    </div>
    <div id="leaderboardScreen" class="screen hidden"><h1>Recordes</h1> <ol id="leaderboardList"></ol> <button id="backToMenuButton" class="button">Voltar</button></div>
    <div id="gameOverModal" class="screen hidden">
        <div id="modalContent"> 
            <h1>Fim de Jogo</h1> 
            <p>Pontuação Final: <span id="finalScoreEl">0</span></p> 
            <p>Inimigos Derrotados: <span id="finalEnemiesDefeatedEl">0</span></p> 
            <p>Tempo Sobrevivido: <span id="finalTimeSurvivedEl">0</span>s</p>
            <button id="menuReturnButton" class="button">Voltar ao Menu</button> 
        </div>
    </div>
    
    <!-- Tela de Upgrade para Mobile -->
    <div id="mobileUpgradeScreen" class="screen hidden" style="background: rgba(13, 2, 33, 0.9);">
        <h1>Upgrades</h1>
        <div class="upgrade-container">
            <!-- Os cards de upgrade serão inseridos aqui pelo JS -->
        </div>
        <button id="closeUpgradeScreen" class="button">Fechar</button>
    </div>


    <div id="gameContainer" class="hidden">
        <canvas id="gameCanvas"></canvas>
        <div id="top-left-ui">
            <div id="stats-display">
                <span>Horda: <span id="waveEl">0</span></span>
                <span>Pontos: <span id="scoreEl">0</span></span>
                <span>Pontuação Geral: <span id="totalScoreEl">0</span></span>
            </div>
            <div id="health-bar-container"> <div id="health-bar"></div> <div id="health-text"></div> </div>
             <button id="exitButton" class="button" style="padding: 5px 10px; font-size: 0.8em; margin-top: 5px;">Sair e Salvar</button>
        </div>
        
        <div id="tutorial-overlay" class="hidden"></div>

        <!-- UI para PC -->
        <div id="pc-bottom-ui" class="hidden">
             <div id="pc-upgrades-ui">
                 <!-- Cards de Upgrade para PC -->
             </div>
            <div id="pc-abilities-ui">
                 <div id="abilities-row">
                     <div id="shield-ability" class="ability">🛡️<div class="cooldown-overlay"></div><span class="ability-key">Q</span></div>
                     <div id="hunter-ability" class="ability">💥<div class="cooldown-overlay"></div><span class="ability-key">RMB</span></div>
                     <div id="predator-ability" class="ability">🚀<div class="cooldown-overlay"></div><span class="ability-key">E/S+X</span><span class="count-display">0</span></div>
                 </div>
            </div>
        </div>

         <!-- UI para Mobile -->
         <div id="mobile-controls" class="hidden">
             <div id="joystick-container">
                 <div class="joystick-zone" id="joystick-zone-left"><div class="joystick-base"><div class="joystick-stick"></div></div></div>
                 <div class="joystick-zone" id="joystick-zone-right"><div class="joystick-base"><div class="joystick-stick"></div></div></div>
             </div>
              <div id="mobile-abilities-ui">
                 <div id="mobile-shield-ability" class="ability">🛡️<div class="cooldown-overlay"></div></div>
                 <div id="mobile-hunter-ability" class="ability">💥<div class="cooldown-overlay"></div></div>
                 <div id="mobile-predator-ability" class="ability">🚀<span class="count-display">0</span></div>
                 <div id="mobile-upgrade-button" class="ability">UP</div>
                 <div id="mobile-flot-ability" class="ability">🛰️<span class="count-display">0</span></div>
                 <div id="mobile-defense-drone-ability" class="ability">🔵<span class="count-display">0</span></div>
             </div>
         </div>
    </div>

    <script>
    window.addEventListener('DOMContentLoaded', () => {
        const getEl = (id) => document.getElementById(id);
        const menuScreen = getEl('menuScreen'), leaderboardScreen = getEl('leaderboardScreen'), gameContainer = getEl('gameContainer'), gameOverModal = getEl('gameOverModal'), mobileUpgradeScreen = getEl('mobileUpgradeScreen');
        const startPCButton = getEl('startPCButton'), startMobileButton = getEl('startMobileButton'), leaderboardButton = getEl('leaderboardButton'), backToMenuButton = getEl('backToMenuButton'), menuReturnButton = getEl('menuReturnButton'), tutorialButton = getEl('tutorialButton');
        const challengePCButton = getEl('challengePCButton'), challengeMobileButton = getEl('challengeMobileButton');
        const continueButton = getEl('continueButton'), exitButton = getEl('exitButton');
        const mobileUpgradeButton = getEl('mobile-upgrade-button'), closeUpgradeScreenButton = getEl('closeUpgradeScreen');
        const playerNameInput = getEl('playerNameInput'), canvas = getEl('gameCanvas'), ctx = canvas ? canvas.getContext('2d') : null;
        const scoreEl = getEl('scoreEl'), totalScoreEl = getEl('totalScoreEl'), waveEl = getEl('waveEl'), finalScoreEl = getEl('finalScoreEl'), finalEnemiesDefeatedEl = getEl('finalEnemiesDefeatedEl'), finalTimeSurvivedEl = getEl('finalTimeSurvivedEl'), healthBar = getEl('health-bar'), healthText = getEl('health-text');
        const pcUI = getEl('pc-bottom-ui'), mobileUI = getEl('mobile-controls');
        const tutorialOverlay = getEl('tutorial-overlay');

        let player, bosses, bullets, enemies, particles, enemyBullets, explosions, predatorMissiles, flotDrones, defenseDrones, stars, magneticWaves, arietes, arieteBullets, fireBreaths, sniperBullets;
        let score, currentWave, enemyLevel, nextLevelScore, animationId, controlMode, currentPlayerName, missileChargeTimer, shootCooldown, lastHealTime, pointMultiplier;
        let isChallengeMode, enemiesDefeated, gameStartTime, isPaused = false;
        let moveJoystick, shootJoystick;
        let waveTransition = { active: false, timer: 0, duration: 5000 };
        let tutorialActive = false, tutorialStep = 0, tutorialDummy, tutorialMoved = false;
        
        const keys = { w: false, a: false, s: false, d: false, q: false, e: false, f: false, '1': false, '2': false, '3': false, 'c': false, 'shift': false, 'x': false, 'escape': false };
        const mouse = { x: 0, y: 0, leftDown: false };
        
        const abilities = {
            shield: { duration: 20000, cooldown: 30000, active: false, onCooldown: false, timer: 0 },
            hunter: { duration: 20000, cooldown: 30000, active: false, onCooldown: false, timer: 0 },
            predator: { max: 20, current: 0, chargeTime: 5000 },
            flot: { cost: 300, currentCost: 300 },
            defense: { cost: 250, currentCost: 250 }
        };
        const upgrades = {
            health: { name: 'Vida', icon: '❤️', cost: 200, level: 0, key: '1' },
            damage: { name: 'Dano', icon: '💥', cost: 1000, level: 0, key: '2' },
            speed: { name: 'Velocidade', icon: '⚡', cost: 500, level: 0, key: '3' },
            flot: { name: 'Drone Ataque', icon: '🛰️', cost: 300, level: 0, key: 'f' },
            defense: { name: 'Drone Defesa', icon: '🔵', cost: 250, level: 0, key: 'c' }
        };
        const SAVE_GAME_KEY = 'dextroySaveGame';
        const LEADERBOARD_KEY = 'spaceShooterLeaderboardV6';
        const TOTAL_SCORE_KEY = 'dextroyTotalScore';

        // --- NAVIGATION AND SETUP ---
        startPCButton.addEventListener('click', () => startGame('pc', false));
        startMobileButton.addEventListener('click', () => startGame('mobile', false));
        challengePCButton.addEventListener('click', () => startGame('pc', true));
        challengeMobileButton.addEventListener('click', () => startGame('mobile', true));
        tutorialButton.addEventListener('click', () => startTutorial());
        if(continueButton) continueButton.addEventListener('click', () => loadAndContinueGame());
        if(exitButton) exitButton.addEventListener('click', () => saveAndExit());
        mobileUpgradeButton.addEventListener('click', toggleUpgradeScreen);
        closeUpgradeScreenButton.addEventListener('click', toggleUpgradeScreen);

        function toggleUpgradeScreen() {
            isPaused = !isPaused;
            mobileUpgradeScreen.classList.toggle('hidden');
            if(!isPaused) {
                missileChargeTimer = setInterval(() => { if (player && abilities.predator.current < abilities.predator.max) { abilities.predator.current++; } }, abilities.predator.chargeTime);
                animate(); 
            } else {
                cancelAnimationFrame(animationId);
                clearInterval(missileChargeTimer);
                updateUI();
            }
        }

        function startTutorial() {
            menuScreen.classList.add('hidden');
            gameContainer.classList.remove('hidden');
            pcUI.classList.add('hidden');
            mobileUI.classList.add('hidden');
            tutorialActive = true;
            tutorialStep = 1;
            controlMode = 'pc';
            initGame(true);
            updateTutorialUI();
        }

        function endTutorial() {
            tutorialActive = false;
            cancelAnimationFrame(animationId);
            gameContainer.classList.add('hidden');
            tutorialOverlay.classList.add('hidden');
            menuScreen.classList.remove('hidden');
        }

        function startGame(mode, challenge = false, savedState = null) {
            currentPlayerName = playerNameInput.value || "Jogador"; 
            controlMode = mode;
            isChallengeMode = challenge;
            menuScreen.classList.add('hidden'); 
            gameContainer.classList.remove('hidden');
            
            if (controlMode === 'pc') { 
                pcUI.classList.remove('hidden'); 
                mobileUI.classList.add('hidden');
                gameContainer.classList.add('crosshair-cursor'); 
            } else { 
                pcUI.classList.add('hidden'); 
                mobileUI.classList.remove('hidden');
                gameContainer.classList.remove('crosshair-cursor'); 
            }
            initGame(false, savedState);
        }
        
        leaderboardButton.addEventListener('click', () => { 
            displayLeaderboard();
            leaderboardScreen.classList.remove('hidden'); 
            menuScreen.classList.add('hidden'); 
        });
        backToMenuButton.addEventListener('click', () => { 
            menuScreen.classList.remove('hidden'); 
            leaderboardScreen.classList.add('hidden'); 
        });
        menuReturnButton.addEventListener('click', () => { 
            gameOverModal.classList.add('hidden'); 
            gameContainer.classList.add('hidden');
            menuScreen.classList.remove('hidden');
            loadAndDisplayTotalScore(); // Refresh total score display
            if (localStorage.getItem(SAVE_GAME_KEY)) {
                continueButton.classList.remove('hidden');
            }
        });

        // --- Leaderboard and Score Functions ---
        const getScores = () => JSON.parse(localStorage.getItem(LEADERBOARD_KEY) || '[]');
        function saveScore(name, score) { 
            if (score <= 0) return; 
            const scores = getScores(); 
            scores.push({ name, score }); 
            scores.sort((a, b) => b.score - a.score); 
            localStorage.setItem(LEADERBOARD_KEY, JSON.stringify(scores.slice(0, 10))); 
        }
        function displayLeaderboard() { 
            const list = getEl('leaderboardList');
            const scores = getScores();
            list.innerHTML = scores.length ? scores.map(r => `<li><span>${r.name}</span><span>${r.score}</span></li>`).join('') : '<li>Nenhum recorde ainda.</li>'; 
        }
        function loadAndDisplayTotalScore() {
            const totalScore = parseInt(localStorage.getItem(TOTAL_SCORE_KEY) || '0');
            if (totalScoreEl) totalScoreEl.innerText = totalScore;
        }
        
        // --- GAME CLASSES ---
        class Player { 
            constructor(x, y) {
                this.x = x; this.y = y;
                this.radius = 20;
                this.speed = 4;
                this.angle = 0;
                this.maxHp = 500; this.hp = 500;
                this.velocity = { x: 0, y: 0 };
                this.damageMultiplier = 1;
                this.lastHitTime = 0;
                this.invincibilityDuration = 1000;
            } 
            draw() {
                const isInvincible = controlMode === 'pc' && (Date.now() - this.lastHitTime < this.invincibilityDuration);
                ctx.save();
                if (isInvincible && !abilities.shield.active) {
                    ctx.globalAlpha = Math.floor(Date.now() / 100) % 2 === 0 ? 0.5 : 1.0;
                }
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.rotate(this.angle);
                const engineGlowIntensity = (Math.abs(this.velocity.x) + Math.abs(this.velocity.y)) > 0 ? 1 : 0.5;
                const engineGlow = ctx.createRadialGradient(0, 18, 2, 0, 18, 12);
                engineGlow.addColorStop(0, `rgba(100, 180, 255, ${0.8 * engineGlowIntensity})`);
                engineGlow.addColorStop(1, 'rgba(100, 180, 255, 0)');
                ctx.fillStyle = engineGlow;
                ctx.beginPath();
                ctx.arc(0, 18, 12, 0, Math.PI * 2);
                ctx.fill();
                const bodyGradient = ctx.createLinearGradient(0, -this.radius, 0, this.radius);
                bodyGradient.addColorStop(0, '#d4d8dd');
                bodyGradient.addColorStop(0.5, '#898c90');
                bodyGradient.addColorStop(1, '#5b5e61');
                ctx.fillStyle = bodyGradient;
                ctx.strokeStyle = '#333';
                ctx.lineWidth = 1.5;
                ctx.beginPath();
                ctx.moveTo(0, -22);
                ctx.lineTo(14, 10);
                ctx.lineTo(12, 18);
                ctx.lineTo(-12, 18);
                ctx.lineTo(-14, 10);
                ctx.closePath();
                ctx.fill();
                ctx.stroke();
                const cockpitGradient = ctx.createRadialGradient(0, -8, 1, 0, -8, 8);
                cockpitGradient.addColorStop(0, 'rgba(100, 220, 255, 1)');
                cockpitGradient.addColorStop(1, 'rgba(0, 100, 150, 0.8)');
                ctx.fillStyle = cockpitGradient;
                ctx.strokeStyle = '#7ccfff';
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.arc(0, -9, 7, 0, Math.PI * 2);
                ctx.fill();
                ctx.stroke();
                ctx.restore();
                if (abilities.shield.active) {
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, this.radius + 10, 0, Math.PI * 2);
                    ctx.strokeStyle = `rgba(0, 255, 255, ${0.2 + Math.random() * 0.5})`;
                    ctx.lineWidth = 3;
                    ctx.shadowBlur = 15;
                    ctx.shadowColor = "cyan";
                    ctx.stroke();
                    ctx.shadowBlur = 0;
                }
                ctx.restore();
            } 
            update() {
                this.draw();
                if (controlMode === 'pc') {
                    this.angle = Math.atan2(mouse.y - this.y, mouse.x - this.x) + Math.PI / 2;
                    this.velocity.x = 0;
                    this.velocity.y = 0;
                    if (keys.w) { this.velocity.y = -1; if(tutorialActive) tutorialMoved = true; }
                    if (keys.s) { this.velocity.y = 1;  if(tutorialActive) tutorialMoved = true; }
                    if (keys.a) { this.velocity.x = -1; if(tutorialActive) tutorialMoved = true; }
                    if (keys.d) { this.velocity.x = 1;  if(tutorialActive) tutorialMoved = true; }
                } else if (moveJoystick) {
                    this.velocity = moveJoystick.vector;
                    if (shootJoystick && (shootJoystick.vector.x !== 0 || shootJoystick.vector.y !== 0)) {
                        this.angle = Math.atan2(shootJoystick.vector.y, shootJoystick.vector.x) + Math.PI / 2;
                    }
                }
                const magnitude = Math.sqrt(this.velocity.x**2 + this.velocity.y**2);
                if (magnitude > 1) {
                    this.velocity.x /= magnitude;
                    this.velocity.y /= magnitude;
                }
                this.x += this.velocity.x * this.speed;
                this.y += this.velocity.y * this.speed;
                this.x = Math.max(this.radius, Math.min(canvas.width - this.radius, this.x));
                this.y = Math.max(this.radius, Math.min(canvas.height - this.radius, this.y));
            } 
            takeDamage(amount) {
                const now = Date.now();
                if (abilities.shield.active) return;
                if (controlMode === 'pc' && now - this.lastHitTime < this.invincibilityDuration) return;

                this.lastHitTime = now;
                this.hp = Math.max(0, this.hp - amount);
                updateHealthBar();
                if (this.hp <= 0) endGame();
            }
        }

        class Bullet { 
            constructor(x, y, v, isExplosive = false, dmgMult = 1) {
                this.x = x; this.y = y;
                this.radius = 4;
                this.color = isExplosive ? '#FF8C00' : '#00ffff';
                this.velocity = v;
                this.speed = 12;
                this.isExplosive = isExplosive;
                this.damage = (isExplosive ? 3 : 1) * dmgMult;
                this.length = 15;
            } 
            draw() {
                ctx.save();
                ctx.beginPath();
                ctx.moveTo(this.x, this.y);
                ctx.lineTo(this.x - this.velocity.x * this.length, this.y - this.velocity.y * this.length);
                ctx.strokeStyle = this.color;
                ctx.lineWidth = this.isExplosive ? 4 : 2;
                ctx.shadowBlur = 10;
                ctx.shadowColor = this.color;
                ctx.stroke();
                ctx.restore();
            } 
            update() {
                this.draw();
                this.x += this.velocity.x * this.speed;
                this.y += this.velocity.y * this.speed;
            } 
        }
        
        class Enemy { 
            constructor(x, y, level) {
                this.x = x; this.y = y; this.level = level;
                this.radius = 12 + level * 2;
                this.health = level * 2; this.maxHealth = level * 2;
                this.points = 20 * Math.pow(2, level - 1);
                this.color = `hsl(${360 - level * 40}, 90%, 50%)`;
                this.shootCooldown = 2000 - level * 200;
                this.lastShot = Date.now();
            } 
            draw() {
                ctx.save();
                ctx.translate(this.x, this.y);
                if (player) ctx.rotate(Math.atan2(player.y - this.y, player.x - this.x) + Math.PI / 2);
                ctx.fillStyle = this.color;
                ctx.strokeStyle = 'black';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(0, -this.radius);
                ctx.quadraticCurveTo(this.radius, 0, this.radius * 0.7, this.radius);
                ctx.lineTo(-this.radius * 0.7, this.radius);
                ctx.quadraticCurveTo(-this.radius, 0, 0, -this.radius);
                ctx.closePath();
                ctx.shadowBlur = 10;
                ctx.shadowColor = this.color;
                ctx.fill();
                ctx.stroke();
                ctx.shadowBlur = 0;
                ctx.restore();
            }
            update() {
                this.draw();
                if (!player) return; 
                const angle = Math.atan2(player.y - this.y, player.x - this.x);
                const speed = (this.speed_override !== undefined) ? this.speed_override : (0.8 + (this.level * 0.2));
                this.x += Math.cos(angle) * speed;
                this.y += Math.sin(angle) * speed;
                if (Date.now() - this.lastShot > this.shootCooldown) {
                    this.shoot();
                }
            } 
            shoot() {
                if (!player) return; 
                const angle = Math.atan2(player.y - this.y, player.x - this.x);
                const damage = 2 * Math.pow(1.3, this.level - 1);
                enemyBullets.push(new EnemyBullet(this.x, this.y, { x: Math.cos(angle), y: Math.sin(angle) }, this.level, damage));
                this.lastShot = Date.now();
            }
        }
        
        class EnemyBullet { 
            constructor(x, y, v, level, dmg) {
                this.x = x; this.y = y;
                this.velocity = v; this.level = level; this.damage = dmg;
                this.radius = 4 + level;
                this.speed = 3 + level * 0.5;
                this.isExplosive = level >= 3;
                this.isHoming = level >= 4;
                this.isDoT = level >= 5;
                this.color = this.isDoT ? '#ff4d4d' : (this.isExplosive ? '#ff8c00' : '#ff00ff'); 
                this.health = this.isHoming ? 3 : 1;
            } 
            draw() {
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                ctx.fillStyle = this.color;
                ctx.shadowBlur = 10;
                ctx.shadowColor = this.color;
                ctx.fill();
                ctx.shadowBlur = 0;
            } 
            update() {
                if (this.isHoming && player) {
                    const angle = Math.atan2(player.y - this.y, player.x - this.x);
                    this.velocity.x = Math.cos(angle);
                    this.velocity.y = Math.sin(angle);
                }
                this.draw();
                this.x += this.velocity.x * this.speed;
                this.y += this.velocity.y * this.speed;
            }
        }

        class ArieteBullet {
            constructor(x, y, v) {
                this.x = x; this.y = y;
                this.velocity = v;
                this.radius = 8;
                this.speed = 4;
                this.color = '#FFA500';
            }
            draw() {
                ctx.save();
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                ctx.fillStyle = this.color;
                ctx.strokeStyle = 'red';
                ctx.lineWidth = 2;
                ctx.shadowBlur = 10;
                ctx.shadowColor = this.color;
                ctx.fill();
                ctx.stroke();
                ctx.restore();
            }
            update() {
                this.draw();
                this.x += this.velocity.x * this.speed;
                this.y += this.velocity.y * this.speed;
            }
        }
        
        class SniperBullet {
            constructor(x, y, v) {
                this.x = x; this.y = y;
                this.velocity = v;
                this.radius = 3;
                this.speed = 15;
                this.color = '#FFFF00'; // Yellow
                this.damage = 50;
            }
            draw() {
                ctx.save();
                ctx.beginPath();
                ctx.moveTo(this.x, this.y);
                ctx.lineTo(this.x - this.velocity.x * 20, this.y - this.velocity.y * 20);
                ctx.strokeStyle = this.color;
                ctx.lineWidth = 3;
                ctx.shadowBlur = 15;
                ctx.shadowColor = this.color;
                ctx.stroke();
                ctx.restore();
            }
            update() {
                this.draw();
                this.x += this.velocity.x * this.speed;
                this.y += this.velocity.y * this.speed;
            }
        }

        class Particle { 
            constructor(x, y, r, c, velocity) {
                this.x = x; this.y = y; this.radius = r; this.color = c;
                this.velocity = velocity || { x: (Math.random() - 0.5) * (Math.random() * 4), y: (Math.random() - 0.5) * (Math.random() * 4) };
                this.alpha = 1;
                this.life = Math.random() * 60 + 30;
                this.initialLife = this.life;
            } 
            draw() {
                ctx.save();
                ctx.globalAlpha = this.alpha;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                ctx.fillStyle = this.color;
                ctx.fill();
                ctx.restore();
            } 
            update() {
                this.draw();
                this.x += this.velocity.x;
                this.y += this.velocity.y;
                this.life--; 
                this.alpha = this.life / this.initialLife;
            }
        }

        class FireBreath {
            constructor(x, y, angle) {
                this.x = x;
                this.y = y;
                this.angle = angle;
                this.duration = 3000;
                this.startTime = Date.now();
                this.alpha = 1;
                this.damageInterval = 100;
                this.lastDamageTime = 0;
            }
            update() {
                const elapsedTime = Date.now() - this.startTime;
                if (elapsedTime > this.duration) {
                    this.alpha = 0;
                    return;
                }
                for (let i = 0; i < 5; i++) {
                    const speed = Math.random() * 5 + 3;
                    const spread = (Math.random() - 0.5) * 0.5;
                    const vel = { x: Math.cos(this.angle + spread) * speed, y: Math.sin(this.angle + spread) * speed };
                    const life = Math.random() * 40 + 20;
                    const color = `rgba(255, ${Math.random() * 150}, 0, 0.8)`;
                    particles.push(new Particle(this.x, this.y, Math.random() * 4 + 2, color, vel));
                }
            }
        }
        
        class Explosion { 
            constructor(x, y, baseRadius) {
                this.x = x; this.y = y; this.baseRadius = baseRadius;
                this.particles = [];
                this.alpha = 1;
                this.init();
            }
            init() {
                const particleCount = this.baseRadius * 1.5;
                const colors = ['#ffffff', '#ffc857', '#ffac33', '#e67700', '#d95d00', '#bf4700', '#222', '#ff4500'];
                for (let i = 0; i < particleCount; i++) {
                    this.particles.push(new Particle(this.x, this.y, Math.random() * 3 + 1, colors[Math.floor(Math.random() * colors.length)]));
                }
            }
            update() {
                this.particles.forEach((p, i) => {
                    p.update();
                    if (p.alpha <= 0) this.particles.splice(i, 1);
                });
                this.alpha -= 0.04;
            }
        }
        
        class PredatorMissile { 
            constructor(x, y) {
                this.x = x; this.y = y;
                this.target = null;
                this.radius = 8;
                this.speed = 8;
            } 
            findTarget() {
                let bestTarget = null;
                let maxScore = -1;
                const targets = [...enemies, ...bosses, ...arietes];
                targets.forEach(t => {
                    if (!t) return;
                    const dist = Math.hypot(this.x - t.x, this.y - t.y);
                    const score = (t.level || 10) * 100 - dist;
                    if (score > maxScore) {
                        maxScore = score;
                        bestTarget = t;
                    }
                });
                this.target = bestTarget;
            } 
            update() {
                if (!this.target || this.target.health <= 0) this.findTarget();
                if (this.target) {
                    const angle = Math.atan2(this.target.y - this.y, this.target.x - this.x);
                    this.x += Math.cos(angle) * this.speed;
                    this.y += Math.sin(angle) * this.speed;
                    if (Math.hypot(this.x - this.target.x, this.y - this.target.y) < this.speed * 2) this.detonate();
                } else {
                    this.y -= this.speed;
                    if (this.y < 0) predatorMissiles.splice(predatorMissiles.indexOf(this), 1);
                }
                this.draw();
            } 
            draw() {
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.rotate(this.target ? Math.atan2(this.target.y - this.y, this.target.x - this.x) + Math.PI / 2 : 0);
                ctx.fillStyle = 'white';
                ctx.beginPath();
                ctx.moveTo(0, -10); ctx.lineTo(5, 5); ctx.lineTo(-5, 5);
                ctx.closePath();
                ctx.fill();
                particles.push(new Particle(this.x, this.y, 3, '#ff4500'));
                ctx.restore();
            } 
            detonate() {
                createExplosion(this.x, this.y, 150);
                [...enemies, ...bosses, ...arietes].forEach(e => {
                    if (Math.hypot(this.x - e.x, this.y - e.y) < 150) e.health -= 30;
                });
                predatorMissiles.splice(predatorMissiles.indexOf(this), 1);
            }
        }
        
        class FinalBoss extends Enemy {
             constructor(x, y) {
                super(x, y, 20);
                this.maxHealth = 20000;
                this.health = 20000;
                this.radius = 80;
                this.points = 50000;
                this.speed_override = 0.5;
                this.shootCooldown = 4000;
                this.color = '#8B0000';
                this.name = "Aniquilador Estelar";
             }

             shoot() {
                if (!player) return;
                this.lastShot = Date.now();
                const angle = Math.atan2(player.y - this.y, player.x - this.x);
                fireBreaths.push(new FireBreath(this.x, this.y, angle));
             }

             draw() {
                ctx.save();
                ctx.translate(this.x, this.y);
                const healthPercentage = this.health / this.maxHealth;
                ctx.fillStyle = 'grey';
                ctx.fillRect(-this.radius, -this.radius - 20, this.radius * 2, 10);
                ctx.fillStyle = 'red';
                ctx.fillRect(-this.radius, -this.radius - 20, this.radius * 2 * healthPercentage, 10);

                if (player) ctx.rotate(Math.atan2(player.y - this.y, player.x - this.x) + Math.PI / 2);
                ctx.fillStyle = this.color;
                ctx.strokeStyle = '#FF0000';
                ctx.lineWidth = 4;
                ctx.shadowColor = 'red';
                ctx.shadowBlur = 20;
                ctx.beginPath();
                ctx.moveTo(0, -this.radius);
                ctx.quadraticCurveTo(this.radius * 0.8, -this.radius * 0.5, this.radius, this.radius * 0.2);
                ctx.lineTo(this.radius * 0.5, this.radius);
                ctx.lineTo(-this.radius * 0.5, this.radius);
                ctx.lineTo(-this.radius, this.radius * 0.2);
                ctx.quadraticCurveTo(-this.radius * 0.8, -this.radius * 0.5, 0, -this.radius);
                ctx.closePath();
                ctx.fill();
                ctx.stroke();

                ctx.restore();
             }
        }

        class StealthEnemy extends Enemy {
            constructor(x, y) {
                super(x, y, 3);
                this.speed_override = 2.5;
                this.points = 150;
                this.color = '#9400D3';
                this.isInvisible = false;
                this.lastVisibilityChange = Date.now();
                this.visibilityDuration = 2000;
            }

            update() {
                if (Date.now() - this.lastVisibilityChange > this.visibilityDuration) {
                    this.isInvisible = !this.isInvisible;
                    this.lastVisibilityChange = Date.now();
                }
                super.update();
            }

            draw() {
                if (this.isInvisible) return;
                ctx.save();
                ctx.globalAlpha = 0.7;
                super.draw();
                ctx.restore();
            }
        }

        class TankEnemy extends Enemy {
            constructor(x, y) {
                super(x, y, 4);
                this.speed_override = 0.5;
                this.health = 40;
                this.points = 200;
                this.color = '#A9A9A9';
                this.radius = 25;
            }
            shoot() {}
        }

        class SniperEnemy extends Enemy {
            constructor(x, y) {
                super(x, y, 5);
                this.speed_override = 0.3;
                this.points = 250;
                this.color = '#00CED1';
                this.shootCooldown = 3000;
                this.preferredDistance = 400;
            }
            update() {
                this.draw();
                if (!player) return;
                const angle = Math.atan2(player.y - this.y, player.x - this.x);
                const distance = Math.hypot(player.x - this.x, player.y - this.y);
                if (distance > this.preferredDistance) {
                    this.x += Math.cos(angle) * this.speed_override;
                    this.y += Math.sin(angle) * this.speed_override;
                } else {
                    this.x -= Math.cos(angle) * this.speed_override;
                    this.y -= Math.sin(angle) * this.speed_override;
                }
                if (Date.now() - this.lastShot > this.shootCooldown) {
                    this.shoot();
                }
            }
            shoot() {
                if (!player) return;
                const angle = Math.atan2(player.y - this.y, player.x - this.x);
                sniperBullets.push(new SniperBullet(this.x, this.y, { x: Math.cos(angle), y: Math.sin(angle) }));
                this.lastShot = Date.now();
            }
        }
        
        class FlotDrone { 
            constructor(x, y) {
                this.x = x; this.y = y; this.radius = 8; this.health = 100; this.maxHealth = 100;
                this.target = null; this.lastShot = 0; this.shootCooldown = 500;
            } 
            findTarget() {
                let bestTarget = null; let min_dist = Infinity;
                [...enemies, ...bosses, ...arietes].forEach(t => {
                    if (!t) return;
                    const dist = Math.hypot(this.x - t.x, this.y - t.y);
                    if (dist < min_dist) { min_dist = dist; bestTarget = t; }
                });
                this.target = bestTarget;
            } 
            update(index, totalDrones) {
                if (!player) return;
                if (!this.target || this.target.health <= 0) this.findTarget();
                const orbitRadius = 80;
                const orbitAngle = (Date.now() / 2000) + (index * (Math.PI * 2 / totalDrones));
                const targetX = player.x + Math.cos(orbitAngle) * orbitRadius;
                const targetY = player.y + Math.sin(orbitAngle) * orbitRadius;
                const angle = Math.atan2(targetY - this.y, targetX - this.x);
                this.x += Math.cos(angle) * 3;
                this.y += Math.sin(angle) * 3;
                if (this.target && Date.now() - this.lastShot > this.shootCooldown) {
                    this.shoot();
                    this.lastShot = Date.now();
                }
                this.draw();
            } 
            shoot() {
                if (!this.target) return;
                const angle = Math.atan2(this.target.y - this.y, this.target.x - this.x);
                const damage = this.target instanceof Enemy ? 20 : 30;
                bullets.push(new Bullet(this.x, this.y, { x: Math.cos(angle), y: Math.sin(angle) }, false, damage / player.damageMultiplier));
            } 
            draw() {
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.rotate(Date.now() / 1000);
                ctx.beginPath();
                ctx.rect(-this.radius, -this.radius, this.radius * 2, this.radius * 2);
                ctx.strokeStyle = 'lime'; ctx.lineWidth = 2;
                ctx.shadowBlur = 10; ctx.shadowColor = 'lime';
                ctx.stroke();
                ctx.fillStyle = `rgba(0, 255, 0, 0.2)`;
                ctx.fill();
                ctx.restore();
            }
        }
        
        class DefenseDrone { 
            constructor(x, y) {
                this.x = x; this.y = y; this.radius = 12; this.health = 200; this.maxHealth = 200;
            } 
            update(index, totalDrones) {
                if (!player) return;
                const orbitRadius = 60;
                const orbitAngle = -(Date.now() / 2000) + (index * (Math.PI * 2 / totalDrones));
                let targetX = player.x + Math.cos(orbitAngle) * orbitRadius;
                let targetY = player.y + Math.sin(orbitAngle) * orbitRadius;
                const angle = Math.atan2(targetY - this.y, targetX - this.x);
                this.x += Math.cos(angle) * 3;
                this.y += Math.sin(angle) * 3;
                this.draw();
            } 
            draw() {
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.beginPath();
                for (let i = 0; i < 6; i++) { ctx.lineTo(this.radius * Math.cos(i * Math.PI / 3), this.radius * Math.sin(i * Math.PI / 3)); }
                ctx.closePath();
                ctx.strokeStyle = 'lightblue'; ctx.lineWidth = 3;
                ctx.shadowBlur = 10; ctx.shadowColor = 'lightblue';
                ctx.stroke();
                ctx.restore();
            }
        }
        
        class MagneticWave { 
            constructor(x, y) {
                this.x = x; this.y = y; this.radius = 0; this.maxRadius = 300; this.alpha = 1;
                this.hitDrones = [];
            } 
            update() {
                this.radius += 5;
                this.alpha -= 0.02;
                this.draw();
            } 
            draw() {
                ctx.save();
                ctx.globalAlpha = this.alpha;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                ctx.strokeStyle = 'rgba(255,0,255,0.8)'; ctx.lineWidth = 5;
                ctx.stroke();
                ctx.restore();
            }
        }
        
        class MagnetEnemy extends Enemy { 
            constructor(x, y) {
                super(x, y, 5);
                this.shootCooldown = 3000;
            } 
            shoot() {
                if (!player) return;
                magneticWaves.push(new MagneticWave(this.x, this.y));
            }
        }
        
        class Ariete extends Enemy {
            constructor(x, y) {
                super(x, y, 6);
                this.health = 2000; this.points = 3000; this.radius = 30; this.speed_override = 6;
                this.lastShot = Date.now(); this.shootCooldown = 2500;
            } 
            update() {
                this.draw();
                if(!player) return;
                const angle = Math.atan2(player.y - this.y, player.x - this.x);
                this.x += Math.cos(angle) * this.speed_override;
                this.y += Math.sin(angle) * this.speed_override;

                if (Date.now() - this.lastShot > this.shootCooldown) {
                    this.shoot();
                }
            }
            shoot() {
                if (!player) return;
                const angle = Math.atan2(player.y - this.y, player.x - this.x);
                arieteBullets.push(new ArieteBullet(this.x, this.y, {x: Math.cos(angle), y: Math.sin(angle)}));
                this.lastShot = Date.now();
            }
            draw() {
                ctx.save();
                ctx.translate(this.x, this.y);
                if (player) ctx.rotate(Math.atan2(player.y - this.y, player.x - this.x));
                ctx.fillStyle = '#888';
                ctx.beginPath(); ctx.rect(-this.radius, -this.radius / 2, this.radius * 2, this.radius); ctx.fill();
                ctx.fillStyle = '#f00';
                ctx.beginPath(); ctx.arc(this.radius, 0, this.radius / 2, 0, Math.PI * 2); ctx.fill();
                ctx.restore();
            } 
            onDeath() {
                createExplosion(this.x, this.y, this.radius * 2);
                const dronesToDestroy = Math.floor(Math.random() * 3) + 1; // 1, 2, or 3
                const allDrones = [...flotDrones, ...defenseDrones];

                // Simple Fisher-Yates shuffle
                for (let i = allDrones.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [allDrones[i], allDrones[j]] = [allDrones[j], allDrones[i]];
                }
                
                // Destroy the determined number of drones from the shuffled list
                for (let i = 0; i < dronesToDestroy && i < allDrones.length; i++) {
                    allDrones[i].health = 0;
                }
            }
        }
        
        class Star { 
            constructor(x, y, radius, speed) {
                this.x = x; this.y = y; this.radius = radius; this.speed = speed;
                this.alpha = Math.random() * 0.8 + 0.1;
            } 
            draw() {
                ctx.save();
                ctx.globalAlpha = this.alpha;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                ctx.fillStyle = 'white';
                ctx.fill();
                ctx.restore();
            } 
            update() {
                this.y += this.speed;
                if (this.y > canvas.height + this.radius) {
                    this.y = -this.radius;
                    this.x = Math.random() * canvas.width;
                }
                this.draw();
            } 
        }
        
        class Joystick { 
            constructor(zone) {
                this.zone = zone; this.stick = zone.querySelector('.joystick-stick');
                this.active = false; this.touchId = null;
                this.vector = { x: 0, y: 0 }; this.center = { x: 0, y: 0 }; this.stickPos = { x: 0, y: 0 };
                this.zone.addEventListener('touchstart', this.handleTouchStart.bind(this), { passive: false });
                this.zone.addEventListener('touchmove', this.handleTouchMove.bind(this), { passive: false });
                this.zone.addEventListener('touchend', this.handleTouchEnd.bind(this), { passive: false });
            } 
            handleTouchStart(e) {
                e.preventDefault(); if (this.active) return;
                const touch = e.changedTouches[0];
                this.active = true; this.touchId = touch.identifier;
                const rect = this.zone.getBoundingClientRect();
                this.center = { x: rect.left + rect.width / 2, y: rect.top + rect.height / 2 };
                this.updateStick(touch.clientX, touch.clientY);
            } 
            handleTouchMove(e) {
                e.preventDefault(); if (!this.active) return;
                const touch = Array.from(e.changedTouches).find(t => t.identifier === this.touchId);
                if (touch) { this.updateStick(touch.clientX, touch.clientY); }
            } 
            handleTouchEnd(e) {
                e.preventDefault();
                const touch = Array.from(e.changedTouches).find(t => t.identifier === this.touchId);
                if (touch) {
                    this.active = false; this.touchId = null;
                    this.vector = { x: 0, y: 0 };
                    this.stick.style.transform = `translate(0px, 0px)`;
                }
            } 
            updateStick(x, y) {
                const dx = x - this.center.x;
                const dy = y - this.center.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                const maxDistance = this.zone.clientWidth / 4;
                const clampedX = this.center.x + (dx / distance) * Math.min(distance, maxDistance);
                const clampedY = this.center.y + (dy / distance) * Math.min(distance, maxDistance);
                this.stick.style.transform = `translate(${clampedX - this.center.x}px, ${clampedY - this.center.y}px)`;
                this.vector = { x: (clampedX - this.center.x) / maxDistance, y: (clampedY - this.center.y) / maxDistance };
            }
        }
        
        // --- CONTROLS AND ABILITIES ---
        window.addEventListener('keydown', (e) => {
            const k = e.key.toLowerCase();
            if (k in keys) keys[k] = true;
            if (tutorialActive && k === 'escape') { endTutorial(); } 
            else if (controlMode === 'pc') {
                if (k === 'q') activateShield();
                if (k === 'e') activatePredator();
                if (k === 'x' && keys.shift) launchAllPredators();
                if (k === 'f') buyFlotDrone();
                if (k === '1') buyHealthUpgrade();
                if (k === '2') buyDamageUpgrade();
                if (k === '3') buySpeedUpgrade();
                if (k === 'c') buyDefenseDrone();
            }
        });
        window.addEventListener('keyup', (e) => { const k = e.key.toLowerCase(); if (k in keys) keys[k] = false; });
        window.addEventListener('mousemove', (e) => { mouse.x = e.clientX; mouse.y = e.clientY; });
        window.addEventListener('mousedown', (e) => { if (controlMode === 'pc') { e.button === 0 ? mouse.leftDown = true : activateHunter(); } });
        window.addEventListener('mouseup', (e) => { if (controlMode === 'pc' && e.button === 0) mouse.leftDown = false; });
        window.addEventListener('contextmenu', e => { if (controlMode === 'pc') e.preventDefault(); });
        getEl('mobile-shield-ability').addEventListener('click', (e) => { e.preventDefault(); activateShield(); });
        getEl('mobile-hunter-ability').addEventListener('click', (e) => { e.preventDefault(); activateHunter(); });
        getEl('mobile-predator-ability').addEventListener('click', (e) => { e.preventDefault(); activatePredator(); });

        function activateShield() { if (!player || abilities.shield.onCooldown) return; abilities.shield.active = true; abilities.shield.onCooldown = true; abilities.shield.timer = Date.now(); setTimeout(() => abilities.shield.active = false, abilities.shield.duration); setTimeout(() => abilities.shield.onCooldown = false, abilities.shield.cooldown); }
        function activateHunter() { if (!player || abilities.hunter.onCooldown) return; abilities.hunter.active = true; abilities.hunter.onCooldown = true; abilities.hunter.timer = Date.now(); setTimeout(() => abilities.hunter.active = false, abilities.hunter.duration); setTimeout(() => abilities.hunter.onCooldown = false, abilities.hunter.cooldown); }
        function activatePredator() { if (!player || abilities.predator.current <= 0 || predatorMissiles.length > 0) return; abilities.predator.current--; predatorMissiles.push(new PredatorMissile(player.x, player.y)); }
        function launchAllPredators() { if (!player || abilities.predator.current <= 0) return; const numToLaunch = abilities.predator.current; const targets = [...enemies, ...bosses, ...arietes]; for (let i = 0; i < numToLaunch; i++) { const missile = new PredatorMissile(player.x, player.y); if (targets[i]) missile.target = targets[i]; predatorMissiles.push(missile); } abilities.predator.current = 0; }
        
        // --- UPGRADES ---
        function buyHealthUpgrade() { if (!player || score < upgrades.health.cost) return; updateScore(-upgrades.health.cost); const increase = player.maxHp >= 1000 ? 300 : 50; player.maxHp += increase; player.hp += increase; upgrades.health.level++; upgrades.health.cost = player.maxHp >= 1000 ? upgrades.health.cost * 2 : upgrades.health.cost + 100; updateHealthBar(); updateUI(); }
        function buyDamageUpgrade() { if (!player || score < upgrades.damage.cost) return; updateScore(-upgrades.damage.cost); player.damageMultiplier += 0.1; upgrades.damage.level++; upgrades.damage.cost += 500; updateUI(); }
        function buySpeedUpgrade() { if (!player || score < upgrades.speed.cost) return; updateScore(-upgrades.speed.cost); player.speed += 0.5; upgrades.speed.level++; upgrades.speed.cost += 250; updateUI(); }
        function buyFlotDrone() { if (!player || score < upgrades.flot.cost) return; updateScore(-upgrades.flot.cost); flotDrones.push(new FlotDrone(player.x, player.y)); upgrades.flot.cost = Math.floor(upgrades.flot.cost * 1.5); updateUI(); }
        function buyDefenseDrone() { if (!player || score < upgrades.defense.cost) return; updateScore(-upgrades.defense.cost); defenseDrones.push(new DefenseDrone(player.x, player.y)); upgrades.defense.cost = Math.floor(upgrades.defense.cost * 1.5); updateUI(); }

        // --- GAME LOGIC ---
        function initGame(isTutorial = false, savedState = null) {
            canvas.width = window.innerWidth; canvas.height = window.innerHeight;
            if (controlMode === 'mobile') {
                moveJoystick = new Joystick(getEl('joystick-zone-left'));
                shootJoystick = new Joystick(getEl('joystick-zone-right'));
            }
            player = new Player(canvas.width / 2, canvas.height / 2);
            stars = []; for (let i = 0; i < 200; i++) { stars.push(new Star(Math.random() * canvas.width, Math.random() * canvas.height, Math.random() * 2, Math.random() * 0.5 + 0.1)); }
            bullets = []; enemies = []; particles = []; enemyBullets = []; explosions = []; flotDrones = []; predatorMissiles = []; bosses = []; defenseDrones = []; magneticWaves = []; arietes = []; arieteBullets = []; fireBreaths = []; sniperBullets = [];
            score = 0; currentWave = 0; enemyLevel = 1; pointMultiplier = 1; nextLevelScore = 500; shootCooldown = false; lastHealTime = 0; enemiesDefeated = 0;
            gameStartTime = Date.now();
            loadAndDisplayTotalScore();
            Object.values(abilities).forEach(a => { a.active = false; a.onCooldown = false; });
            abilities.predator.current = 0;
            
            // Reset upgrade costs
            upgrades.health.cost = 200; upgrades.health.level = 0;
            upgrades.damage.cost = 1000; upgrades.damage.level = 0;
            upgrades.speed.cost = 500; upgrades.speed.level = 0;
            upgrades.flot.cost = 300;
            upgrades.defense.cost = 250;

            isPaused = false;
            mobileUpgradeScreen.classList.add('hidden');

            if (!isTutorial) { updateScore(0); }
            updateHealthBar();
            buildUpgradeUI();
            if (missileChargeTimer) clearInterval(missileChargeTimer);
            missileChargeTimer = setInterval(() => { if (player && abilities.predator.current < abilities.predator.max) { abilities.predator.current++; } }, abilities.predator.chargeTime);
            if (animationId) cancelAnimationFrame(animationId);
            if (!isTutorial) { startNextWave(); }
            animate();
        }
        function startNextWave() {
            currentWave++; waveEl.innerText = currentWave; pointMultiplier *= 1.1;
            
            if (isChallengeMode && currentWave === 10) {
                 bosses.push(new FinalBoss(canvas.width / 2, -100));
                 return;
            }
            
            const isBossWave = currentWave > 0 && currentWave % 5 === 0;
            if (isBossWave) {
                const bossCount = Math.floor(currentWave / 5);
                for (let i = 0; i < bossCount; i++) { bosses.push(new FinalBoss(canvas.width / 2 + (i * 150 - bossCount * 75), 100)); }
            } else {
                const spawnCount = currentWave * 3;
                for (let i = 0; i < spawnCount; i++) {
                    const level = Math.ceil(Math.random() * enemyLevel);
                    spawnEnemies(level, 1);
                }
                if(currentWave >= 3) spawnEnemies(7, Math.floor(currentWave/3)); // Stealth
                if(currentWave >= 4) spawnEnemies(8, Math.floor(currentWave/4)); // Tank
                if(currentWave >= 6) spawnEnemies(9, Math.floor(currentWave/3)); // Sniper

                if (isChallengeMode) {
                    let arieteCount = Math.floor(currentWave / 2) + 1;
                    spawnEnemies(6, arieteCount);
                } else if (currentWave >= 10) { 
                    let arieteCount = Math.floor((currentWave - 10) / 2) + 1; 
                    spawnEnemies(6, arieteCount); 
                }
            }
        }
        function spawnEnemies(level, count) { for (let i = 0; i < count; i++) { const r = 15 + level * 2; let x, y; if (Math.random() < 0.5) { x = Math.random() < 0.5 ? 0 - r : canvas.width + r; y = Math.random() * canvas.height } else { x = Math.random() * canvas.width; y = Math.random() < 0.5 ? 0 - r : canvas.height + r } 
            if (level === 5) { enemies.push(new MagnetEnemy(x, y)); } 
            else if (level === 6) { arietes.push(new Ariete(x, y)); } 
            else if (level === 7) { enemies.push(new StealthEnemy(x, y)); } 
            else if (level === 8) { enemies.push(new TankEnemy(x, y)); } 
            else if (level === 9) { enemies.push(new SniperEnemy(x, y)); } 
            else { enemies.push(new Enemy(x, y, level)); } } }
        function handleShooting() {
            if (!player) return; let fire = false; let angle = 0;
            if (controlMode === 'pc' && mouse.leftDown) { fire = true; angle = Math.atan2(mouse.y - player.y, mouse.x - player.x); } 
            else if (controlMode === 'mobile' && shootJoystick && (shootJoystick.vector.x !== 0 || shootJoystick.vector.y !== 0)) { fire = true; angle = Math.atan2(shootJoystick.vector.y, shootJoystick.vector.x); }
            if (!fire) return;
            const r = player.angle - Math.PI / 2;
            const nX = player.x + Math.cos(r) * (player.radius - 5), nY = player.y + Math.sin(r) * (player.radius - 5);
            if (abilities.hunter.active) { for (let i = -2; i <= 2; i++) bullets.push(new Bullet(nX, nY, { x: Math.cos(angle + i * 0.15), y: Math.sin(angle + i * 0.15) }, true, player.damageMultiplier)); } 
            else { bullets.push(new Bullet(nX, nY, { x: Math.cos(angle), y: Math.sin(angle) }, false, player.damageMultiplier)); }
        }
        
        function animate() {
            if (isPaused) return;
            animationId = requestAnimationFrame(animate);
            ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            stars.forEach(s => s.update());
            
            const gameArrays = { particles, explosions, bullets, enemyBullets, arieteBullets, sniperBullets, fireBreaths, enemies, bosses, magneticWaves, arietes, flotDrones, defenseDrones, predatorMissiles };
            for (const key in gameArrays) {
                for (let i = gameArrays[key].length - 1; i >= 0; i--) {
                    const item = gameArrays[key][i];
                    if (!item) continue;
                    
                    if (key === 'flotDrones' || key === 'defenseDrones') { item.update(i, gameArrays[key].length); } 
                    else { item.update(); }

                    if (item.health <= 0 || item.alpha <= 0 || (item instanceof PredatorMissile && !item.target && item.y < 0)) {
                        if (item instanceof Ariete) {
                            item.onDeath();
                            updateScore(item.points); enemiesDefeated++;
                        } else if (item instanceof Enemy) { 
                            if(item instanceof FinalBoss) createExplosion(item.x, item.y, item.radius * 2);
                            else createExplosion(item.x, item.y, item.radius); 
                            updateScore(item.points); enemiesDefeated++; 
                        } 
                        else if (item instanceof FlotDrone || item instanceof DefenseDrone) { createExplosion(item.x, item.y, item.radius); }
                        gameArrays[key].splice(i, 1);
                        continue;
                    }
                    if (key === 'bullets' || key === 'enemyBullets' || key === 'arieteBullets' || key === 'sniperBullets') {
                        const b = item;
                        if (b.x < 0 || b.x > canvas.width || b.y < 0 || b.y > canvas.height) {
                            gameArrays[key].splice(i, 1);
                        }
                    }
                }
            }
            
            if (player) player.update();
            
            if (waveTransition.active) {
                const timeRemaining = (waveTransition.duration - (Date.now() - waveTransition.timer)) / 1000;
                if (timeRemaining <= 0) {
                    waveTransition.active = false;
                    startNextWave();
                } else {
                    ctx.font = "40px 'Segoe UI'";
                    ctx.fillStyle = "white";
                    ctx.textAlign = "center";
                    ctx.fillText(`Próxima Horda em ${Math.ceil(timeRemaining)}...`, canvas.width / 2, canvas.height / 2);
                }
            } else {
                if (player && Date.now() - player.lastHitTime > 2000 && player.hp < player.maxHp && Date.now() - lastHealTime > 500) {
                    player.hp = Math.min(player.maxHp, player.hp + 10);
                    lastHealTime = Date.now();
                    updateHealthBar();
                }

                if (!shootCooldown && player) {
                    handleShooting();
                    shootCooldown = true;
                    setTimeout(() => shootCooldown = false, abilities.hunter.active ? 300 : 150);
                }
                checkCollisions();
                if (player && enemies.length === 0 && bosses.length === 0 && arietes.length === 0) {
                    waveTransition.active = true;
                    waveTransition.timer = Date.now();
                }
            }
            
            updateUI();
        }
        
        function checkCollisions() { 
            if (!player) return; 
            
            [...bosses, ...arietes].forEach((b) => { 
                if (Math.hypot(player.x - b.x, player.y - b.y) - b.radius - player.radius < 1) { 
                    if (b instanceof Ariete) {
                        b.health = 0; // The Ariete dies on collision
                    } else { // It's a boss
                        player.takeDamage(100);
                        b.health -= 100;
                    }
                    return;
                } 
                bullets.forEach((bullet, bulletI) => { 
                    if (Math.hypot(bullet.x - b.x, bullet.y - b.y) - b.radius - bullet.radius < 1) { 
                        b.health -= bullet.damage; 
                        bullets.splice(bulletI, 1); 
                    } 
                }); 
            }); 
            enemies.forEach((e) => { 
                if (Math.hypot(player.x - e.x, player.y - e.y) - e.radius - player.radius < 1) { 
                    player.takeDamage(e instanceof TankEnemy ? 80 : 15); e.health = 0; return; 
                } 
                bullets.forEach((b, bI) => { 
                    if (Math.hypot(b.x - e.x, b.y - e.y) - e.radius - b.radius < 1) { 
                        e.health -= b.damage; 
                        if (b.isExplosive) { 
                            createExplosion(b.x, b.y, 50); 
                            enemies.forEach(oE => { if (oE !== e && Math.hypot(b.x - oE.x, b.y - oE.y) < 50) oE.health -= 0.5 * player.damageMultiplier }); 
                        } 
                        bullets.splice(bI, 1); 
                    } 
                }); 
            }); 
            enemyBullets.forEach((eb, ebI) => { 
                if (eb.isHoming) { 
                    bullets.forEach((b, bI) => { 
                        if (Math.hypot(b.x - eb.x, b.y - eb.y) - eb.radius - b.radius < 1) { 
                            eb.health -= b.damage; 
                            bullets.splice(bI, 1); 
                        } 
                    }); 
                } 
                if (Math.hypot(player.x - eb.x, player.y - eb.y) - player.radius - eb.radius < 1) { 
                    player.takeDamage(eb.damage);
                    if (eb.isExplosive) createExplosion(eb.x, eb.y, 10); 
                    enemyBullets.splice(ebI, 1); 
                    return; 
                } 
                defenseDrones.forEach((d) => { 
                    if (Math.hypot(d.x - eb.x, d.y - eb.y) - d.radius - eb.radius < 1) { 
                        d.health -= eb.damage; 
                        enemyBullets.splice(ebI, 1); 
                    } 
                }); 
            }); 
            arieteBullets.forEach((ab, abI) => {
                if (Math.hypot(player.x - ab.x, player.y - ab.y) - player.radius - ab.radius < 1) {
                    player.takeDamage(40);
                    createExplosion(ab.x, ab.y, ab.radius * 2);
                    arieteBullets.splice(abI, 1);
                    return;
                }
                let hitDrone = false;
                [...flotDrones, ...defenseDrones].forEach(d => {
                    if (!hitDrone && Math.hypot(d.x - ab.x, d.y - ab.y) - d.radius - ab.radius < 1) {
                        d.health -= d.maxHealth * 0.20;
                        hitDrone = true;
                    }
                });
                if (hitDrone) {
                    createExplosion(ab.x, ab.y, ab.radius * 2);
                    arieteBullets.splice(abI, 1);
                }
            });
            sniperBullets.forEach((sb, sbI) => {
                 if (Math.hypot(player.x - sb.x, player.y - sb.y) - player.radius - sb.radius < 1) {
                    player.takeDamage(sb.damage);
                    sniperBullets.splice(sbI, 1);
                    return;
                }
            });
            fireBreaths.forEach(fb => {
                const fireConeLength = 200;
                const fireConeWidth = Math.PI / 4;
                const dist = Math.hypot(player.x - fb.x, player.y - fb.y);
                const angleToPlayer = Math.atan2(player.y - fb.y, player.x - fb.x);
                const angleDiff = Math.abs(fb.angle - angleToPlayer);

                if(dist < fireConeLength && angleDiff < fireConeWidth / 2 && Date.now() - fb.lastDamageTime > fb.damageInterval) {
                     player.takeDamage(100 * (fb.damageInterval / 1000));
                     fb.lastDamageTime = Date.now();
                }
            });
            magneticWaves.forEach((mw) => { 
                [...flotDrones, ...defenseDrones].forEach(d => { 
                    if (!mw.hitDrones.includes(d) && Math.hypot(mw.x - d.x, mw.y - d.y) < mw.radius) { 
                        d.health -= d.maxHealth * 0.25; 
                        mw.hitDrones.push(d); 
                    } 
                }); 
            }); 
        }
        
        function createExplosion(x, y, radius) { const particleCount = radius; const colors = ['#ffffff', '#ffc857', '#ffac33', '#e67700', '#d95d00', '#bf4700', '#222']; for (let i = 0; i < particleCount; i++) { particles.push(new Particle(x, y, Math.random() * 2 + 1, colors[Math.floor(Math.random() * colors.length)])); } }
        function updateScore(points) { if (!player) return; score += Math.floor(points * pointMultiplier); scoreEl.innerText = score; if (score >= nextLevelScore) { enemyLevel = Math.min(5, enemyLevel + 1); nextLevelScore += 750; } }
        function updateHealthBar() { if (!player) return; const hp = Math.max(0, player.hp); const p = hp / player.maxHp; healthBar.style.width = `${p * 100}%`; healthBar.style.backgroundColor = p > 0.5 ? '#4CAF50' : (p > 0.2 ? '#FFC107' : '#F44336'); healthText.innerText = `${Math.ceil(hp)}/${player.maxHp} HP`; }
        
        function buildUpgradeUI() {
            const pcContainer = getEl('pc-upgrades-ui');
            const mobileContainer = mobileUpgradeScreen.querySelector('.upgrade-container');
            if(!pcContainer || !mobileContainer) return;
            pcContainer.innerHTML = '';
            mobileContainer.innerHTML = '';

            Object.entries(upgrades).forEach(([key, upg]) => {
                const upgradeFn = () => {
                    switch(key) {
                        case 'health': buyHealthUpgrade(); break;
                        case 'damage': buyDamageUpgrade(); break;
                        case 'speed': buySpeedUpgrade(); break;
                        case 'flot': buyFlotDrone(); break;
                        case 'defense': buyDefenseDrone(); break;
                    }
                };
                
                // PC Card
                const pcCard = document.createElement('div');
                pcCard.className = 'upgrade-card';
                pcCard.id = `pc-${key}-upgrade`;
                pcCard.innerHTML = `
                    <div class="upgrade-header"><span class="upgrade-icon">${upg.icon}</span><span class="upgrade-title">${upg.name}</span></div>
                    <div class="upgrade-level"></div>
                    <div class="upgrade-buy"><button>+</button><span class="upgrade-cost"></span></div>
                    <div class="ability-key">[${upg.key}]</div>`;
                pcCard.querySelector('button').addEventListener('click', upgradeFn);
                pcContainer.appendChild(pcCard);

                // Mobile Card
                const mobileCard = document.createElement('div');
                mobileCard.className = 'upgrade-card';
                mobileCard.id = `mobile-${key}-upgrade`;
                mobileCard.innerHTML = `
                    <div class="upgrade-info">
                        <div class="upgrade-header"><span class="upgrade-icon">${upg.icon}</span><span class="upgrade-title">${upg.name}</span></div>
                        <div class="upgrade-level"></div>
                        <div class="upgrade-cost"></div>
                    </div>
                    <div class="upgrade-buy"><button>+</button></div>`;
                mobileCard.querySelector('button').addEventListener('click', upgradeFn);
                mobileContainer.appendChild(mobileCard);
            });
        }
        
        function updateUI() {
            if (!player) return;
            getEl('mobile-predator-ability').querySelector('.count-display').innerText = abilities.predator.current;
            
            Object.entries(upgrades).forEach(([key, upg]) => {
                const pcCard = getEl(`pc-${key}-upgrade`);
                const mobileCard = getEl(`mobile-${key}-upgrade`);
                let levelText, costText, currentCost;

                if (key === 'flot' || key === 'defense') {
                    levelText = `${key === 'flot' ? flotDrones.length : defenseDrones.length} comprados`;
                    currentCost = upg.cost;
                    costText = `${currentCost} Pts`;
                } else {
                    levelText = `Nível ${upg.level + 1}`;
                    currentCost = upg.cost;
                    costText = `${currentCost} Pts`;
                }

                if (pcCard) {
                    pcCard.querySelector('.upgrade-level').innerText = levelText;
                    pcCard.querySelector('.upgrade-cost').innerText = costText;
                    const pcBtn = pcCard.querySelector('button');
                    pcBtn.disabled = score < currentCost;
                    pcCard.classList.toggle('disabled', score < currentCost);
                }
                if (mobileCard) {
                    mobileCard.querySelector('.upgrade-level').innerText = levelText;
                    mobileCard.querySelector('.upgrade-cost').innerText = costText;
                    const mobileBtn = mobileCard.querySelector('button');
                    mobileBtn.disabled = score < currentCost;
                    mobileCard.classList.toggle('disabled', score < currentCost);
                }
            });
        }
        function endGame() { 
            if (!player) return; 
            isPaused = true;
            const timeSurvived = Math.floor((Date.now() - gameStartTime) / 1000);
            saveScore(currentPlayerName, score); 
            
            let totalScore = parseInt(localStorage.getItem(TOTAL_SCORE_KEY) || '0');
            totalScore += score;
            localStorage.setItem(TOTAL_SCORE_KEY, totalScore);

            finalScoreEl.innerText = score; 
            finalEnemiesDefeatedEl.innerText = enemiesDefeated;
            finalTimeSurvivedEl.innerText = timeSurvived;
            player = null; 
            cancelAnimationFrame(animationId); 
            clearInterval(missileChargeTimer); 
            gameOverModal.classList.remove('hidden'); 
        }
        window.addEventListener('resize', () => { if (!gameContainer.classList.contains('hidden')) initGame(tutorialActive); });
        
        if (localStorage.getItem(SAVE_GAME_KEY)) {
            continueButton.classList.remove('hidden');
        }
        
        loadAndDisplayTotalScore(); // Display total score on menu load
    });
    </script>
</body>
</html>
